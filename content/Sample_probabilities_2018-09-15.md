layout: post
title: Sample Probability Calculations
slug: sample_probability_20180916
category: probability
tags: 
author: Michal Piekarczyk
date:   2018-09-16 12:00:01 -0500

```python
# This notebook tries to calculate a quantity presented in the video,
# https://www.youtube.com/watch?v=hlM7zdf7zwU&feature=share , 
# "Confidence intervals and margin of error | AP Statistics | Khan Academy"
#
# Given a population of size M, 
# and if the population is split into Group A of size Q,
# and Group B makes up , M - Q,
# , such that p = Q/M
# and if we try to sample with a sample size of n,
#
# , what is the probability, using a sample distribution around p, 
# with sample_sigma = sqrt((p)*(1 - p)/n)
# , that for the sample, the sample proportion observed of group  A, will be, 
# within 2 sample_sigma, of p ?
#
# The general approach here is , initially, to try to use combinatorial math,
# to count how many ways are there of selecting different proportions, in a sample,
# from Group A and Group B.

```


```python
from scipy.special import comb
import math
import numpy as np
from decimal import Decimal
```


```python
import ipdb
```


```python
from __future__ import division
```


```python
parameters = {'M': 100000, # too big !
             'n': 100,
             'Q': 46402}

parameters = {'M': 10000,
             'n': 100,
             'Q': 4640}
```


```python
def get_sample_sigma(p, n):
    return math.sqrt((p*(1-p)/n))
```


```python
get_sample_sigma(9/20, 10)
```




    0.15732132722552272




```python
get_sample_sigma(4640/10000, 100)
```




    0.04987023160162784




```python
## For an arbitrary range, (p - 2*sigma_sample_p , p + 2*sigma_sample_p)
# 
sigma_sample_p = get_sample_sigma(4640/10000, 100)
Q = parameters['Q']; M = parameters['M']; p = Q/M
n = parameters['n']
print p, p*n
print Q - 2*sigma_sample_p*n, Q + 2*sigma_sample_p*n
print p*n - 2*sigma_sample_p*n, p*n + 2*sigma_sample_p*n
```

    0.464 46.4
    4630.02595368 4649.97404632
    36.4259536797 56.3740463203



```python
def make_2sigma_Q_range(params):
    M = params['M']
    n = params['n']
    Q = params['Q']
    p = Q/M ; assert p != 0

    sigma_sample_p = get_sample_sigma(p, n)
    range1 = [p - 2*sigma_sample_p, p + 2*sigma_sample_p]
    range2 = [int(np.floor(x*n)) for x in range1]
    return {'range1': range1, 'range2': range2}
    
```


```python
make_2sigma_Q_range(parameters)
```




    [36, 56]




```python
def calculate_probability_that_sample_prob_is_in_range(params, some_range, ):
    M = params['M']
    n = params['n']
    Q = params['Q']
    p = Q/M ; assert p != 0
    sigma = get_sample_sigma(p, n)
    a, b = some_range
    
    
    denominator = comb(M, n)
    
    numerator = np.sum([
        comb(M - i, n - i) * comb(Q, i)
        for i in range(a, b)
    ])
    
    return numerator/denominator
```


```python
some_range = make_2sigma_Q_range(parameters)

a, b = some_range
print a,b
# prob = ipdb.runcall(calculate_probability_that_sample_prob_is_in_range,               
#                    parameters, some_range)
prob = calculate_probability_that_sample_prob_is_in_range(
                    parameters, some_range)
print prob
```

    36 56
    6775154660566004.0



```python
# Hmm. Solve on super small scale first , 
print "comb(20,10) = ", comb(20,10)
smallparams = {'M': 20, 'Q':9, 'n':10}
print make_2sigma_Q_range(smallparams)
```

    comb(20,10) =  184756.0
    {'range2': [1, 7], 'range1': [0.13535734554895457, 0.7646426544510454]}



```python
# is my numerator right in counting the sampling ways?
np.sum([comb(20-i,10-i)*comb(9,i) for i in range(10)])
```




    5707449.0




```python
# Dang that doesn't look right at all, 5707449.0 >> 184756.0 
# hmm, 
[[i,(20-i,10-i),(9,i)] for i in range(10)]
```




    [[0, (20, 10), (9, 0)],
     [1, (19, 9), (9, 1)],
     [2, (18, 8), (9, 2)],
     [3, (17, 7), (9, 3)],
     [4, (16, 6), (9, 4)],
     [5, (15, 5), (9, 5)],
     [6, (14, 4), (9, 6)],
     [7, (13, 3), (9, 7)],
     [8, (12, 2), (9, 8)],
     [9, (11, 1), (9, 9)]]




```python
# Hm okay, my denominator was probably wrong all along... ðŸ¤”
# ok... try a different version of this function ..

def calculate_probability_that_sample_prob_is_in_range(params, some_range, ):
    M = params['M']
    n = params['n']
    Q = params['Q']
    p = Q/M ; assert p != 0
    sigma = get_sample_sigma(p, n)
    a, b = some_range
    
    assert 0 < a < b < n
    
    denominator = np.sum([
        comb(M - i, n - i) * comb(Q, i)
        for i in range(0, n)
    ])
    
    numerator = np.sum([
        comb(M - i, n - i) * comb(Q, i)
        for i in range(a, b)
    ])
    print 'numerator/denominator = %s/%s' % (numerator, denominator)
    
    return numerator/denominator


# def count_ways_to_choose_group_a_and_b
```


```python
print 'small params, ', smallparams
sample_range_dict = make_2sigma_Q_range(smallparams)
sample_prob_range, variable_range = sample_range_dict['range1'], sample_range_dict['range2']
print 'sample_prob_range, ', sample_prob_range
print 'variable_range, ', variable_range

prob = calculate_probability_that_sample_prob_is_in_range(
                    smallparams, variable_range)
print 'probability that when sampling n from M, that the proportion of the sample'
print 'probability, is within two sigma of the actual group probability'
print ', prob = ', prob
```

    small params,  {'Q': 9, 'M': 20, 'n': 10}
    sample_prob_range,  [0.13535734554895457, 0.7646426544510454]
    variable_range,  [1, 7]
    numerator/denominator = 5511792.0/5707449.0
    probability that when sampling n from M, that the proportion of the sample
    probability, is within two sigma of the actual group probability
    , prob =  0.9657190103669783



```python
# 
# Nice, finally getting a good looking number. ^^.
# Maybe this result is 0.965 and not 0.95 , because my parameters are in the toyrange.

# next, try with the large numbers again ...
parameters100k = {'M': 100000, # too big !
             'n': 100,
             'Q': 46402}
parameters10k = {'M': 10000,
             'n': 1000,
             'Q': 4640}

sample_range_dict = make_2sigma_Q_range(parameters10k)
sample_prob_range, variable_range = sample_range_dict['range1'], sample_range_dict['range2']
range_size = sample_prob_range[1] - sample_prob_range[0]
print 'sample_prob_range, ', sample_prob_range, ', size: ', range_size
print 'variable_range, ', variable_range

prob = calculate_probability_that_sample_prob_is_in_range(
                    parameters10k, variable_range)
print ', prob = ', prob


```

    sample_prob_range,  [0.43245929613974987, 0.4955407038602502] , size:  0.0630814077205
    variable_range,  [432, 495]
    numerator/denominator = inf/inf
    , prob =  nan


    /usr/local/miniconda3/envs/blogplt2/lib/python2.7/site-packages/ipykernel_launcher.py:25: RuntimeWarning: invalid value encountered in double_scalars



```python
# Grr, dang still getting a `nan` as an output, like the numbers are just too big?
```


```python
comb(long(10000), long(1000))
```




    inf




```python
# Okay, try again with this module called gmpy..
#
#
#
```


```python
import gmpy
```


```python
def calculate_probability_that_sample_prob_is_in_range__gmpy(params, some_range, ):
    M = params['M']
    n = params['n']
    Q = params['Q']
    p = Q/M ; assert p != 0
    sigma = get_sample_sigma(p, n)
    a, b = some_range
    
    assert 0 < a < b < n
    
    denominator = np.sum([
        gmpy.comb(M - i, n - i) * gmpy.comb(Q, i)
        for i in range(0, n)
    ])
    
    numerator = np.sum([
        gmpy.comb(M - i, n - i) * gmpy.comb(Q, i)
        for i in range(a, b)
    ])
    print 'numerator/denominator = %s/%s' % (numerator, denominator)
    
    return numerator/denominator


```


```python
parameters100k = {'M': 100000, # too big !
             'n': 100,
             'Q': 46402}
parameters10k = {'M': 10000,
             'n': 5000,
             'Q': 4640}

sample_range_dict = make_2sigma_Q_range(parameters10k)
sample_prob_range, variable_range = sample_range_dict['range1'], sample_range_dict['range2']
range_size = sample_prob_range[1] - sample_prob_range[0]
print 'sample_prob_range, ', sample_prob_range, ', size: ', range_size
print 'variable_range, ', variable_range

prob = calculate_probability_that_sample_prob_is_in_range__gmpy(
                    parameters10k, variable_range)
print ', prob = ', prob


```

    sample_prob_range,  [0.44989456842205816, 0.4781054315779419] , size:  0.0282108631559
    variable_range,  [2249, 2390]
    numerator/denominator = 406646260227882562929595546890831658833130857333480088012541921159188335635213228469064540732979455731694093002872700501672900201639116880591220207199836591718640189348711618284341072291251905051041167823231805359009481806319441429943753584472457826716322507699488893523316152158996895687809705686924017563358574462391124937846476179447897903241352056204989937347816741821452444164484164684338978683322327502878345249861629517380420966690802526738231543374717811778911435024843861507222278938937755921601565884736528406901814346246566896912356504380819552640802801959069986654442024510138183282997534556042608810258798292571247257274018413370330219519891555811583663089636866349134243336993224211951937998243594977086003390513355335699524686326180181092371804444159804720576481274752981284895736011271157078496708290761167540162325775098064802237864745924955099218900743390125584955900458840119782322635673631565831116288585601517822434242537960014079157545967175707151022423799365576523795184088432873017655825925024584848738183873680351332159608240694541473264132842161855839101315812355328276350773230726739002322769078643374373687258105572729947442469322207960806704724844479686915848814727987937856663728349113868267465640137255162997842104856375196433364568614229767272022386928705045932433034081854113188079705759178530157486100903489793648694691575263863601854892026555338304340710766541722955546887775410151920884325194320392015118146106410089724865402632750744373372757858453705668368549215333789589961754394500533950095062963229566118386624854702010646162493269171067383364130010533724177880319055042223840817169768146160775226339861328900700330181626495909523001390350601931727684256172206173593016289131903528068380447599840368347019098425860892521483577214899820478570495903864689869309423729559114887969382027819401577855505115179667621768803141604444844144406133604433073535515121423243935159213657620276184257562094910508120268897735582801829467277813667998322073742826650143645793052014234196682724979559641851248504506803156007985862778289842475745719486592600902696914234510095630315398276138004234392646498432327758824889543089941597522418058649100485949181926177759743167174903590492975507920100289141406667265473308646764408345782486242586015769518680801992741087018230454244256982205721800660824840824712333613395588916498983355220805354529864569837234570035663121852717693258361219551992590120087418238713977329183434111777213595795889684871006556136284004103126006338689267079733897315148042254860380506508330155051896233130914378567805235636377283509462949037497489886490892192399572785526708185717380636770989431618495723029606221500315016735154367013425208168322756040115292963905919680582326151789904328737614240553154633379933184822719744854192497531933192854960211817647832133594274184923981654088252899692117297225488092534595680506485435001239169820078455787543277526676184747904406911764009856452020715175671646250366525287713973168430532091147973760464323480358617494650295813997072308290198130376838619646591171988493081298930296297640298264461282090270951824328319263809160677440792467188550470081641192787738466168273716283856194817138403735528301976390970820057258376995427759361302310105452318120971659822807446832513703429528703636217806571520798561041363633566409923337949829426645607351418700474567919690641176956400715027142365437694209186210558452024018054654788162034628937533912517081631219410264682023390619689312304628866875455696432740464232787553216009671973869828188433443444214109660610860075307001598433104614527726015945050000/1375435566361193112215346881437048377755841706494567687790578773338904454205068776929549565651834530062546302385994413718650297648644758457974866528250922071836991622243360684841529721295889179457841190158670443490381151746938647226086508374788887366968866035471936881534792272427721676538201008233133098517142265172704027606386455107503609521792104267176163273791295544437807368308016169258012550557292920297526080919712667965491282634415430773741910525025854067613040195740808751506890889755022221550555836017357394920133992718744037121178892900986361730136702010253867862055485803890088347428565231166752844371715651211295734431091599324908642644747553697316656310657747178361361258154564459702150343383918418719549877304874735954620544897787709154375638546998513169411326840690577826128130470687465356791816535636036003156188143197042652487224201565539886750017997752417772129803525965579883116573752961483742516766610577261623916218914997196522747907471959332728698853732350201689872339621574887957273559456450987820659097482556174676272219288123540349278617621821618507084003764391746186170004659619620597315667377754755862812100319258837151875970223076076670823247573295790437518993522259068179847552625686555768902624900683662256566339794512764644055217919812369378141762340057515300853461050600912533982762393336728571101147446078354399830027743016332578074959911693274964989435090866726430787238863478350495720182851290126491055639133843800200120850555152478605614914612302900810399771964836118767453658054810990676373238755601818999380124050127586829879451662944963737474202817759402627652341271402436677704459272888069753413816163277051635319398386343646901695779049609038945355014723525630655881780073135380854057197359430867259035882730796450500477686556037695317283478386668026646769409710670678032086920896220438732609173372623246281720560326797982632073453762219458965810305734845681706926662211153804043855293975726055405112312865049259999341700467533708818404899229814570010041439514989881134819347262565521084747437999668705122140922183140272136342674751731985461242592125943320457199036425347689823821025457736539060612155320621505958765258244133386293116973297709995333136512544722757362921604267715135149506543519558039528468985585968853924883653939456263226359901156239922528959172308416288978440560667352364449561424826261349425895869897454941923973453803058358214166902072120635482060590688473019047830862187070983120583511825211739314358595017557736241905102369919091110844201137601192339387714471168397067438516959821492682060217731006136364110774936757680431303886538157042448045627834746096534830766545893838228632591427433243532025785235532430246996873515633398754733705696634786553767117769260941989250588582829345027502058744762635849082504477447796651934696895032779213899365415295838181806413204497420584797006352665437191518504545898424214215908474090746512603048448144782771377219024890619870496168182651746217996952495848736578219783904079501830621110486701888550573349349950528650162408882988807684722898392625161436938468933149625468605262595397980252606885055324018765959438688467407620914849099972856910071281373410386886864642983436097033075332049946417077340673780275024906130742992418960477800075426590747715872324646523628673880834691881244698317756385976657426208166744126956570432060430045656485459330806231078774640550230623871773666818218865531721353586309777822650160587181417505160613460107621916251283243671386925414053533199922923919784984468768373513155504153653051867174009550814563619320863710915885052994518698771817070468730662303789202186292561062519129311950978497980738988245470737703272217579488960499701118371594839954410355373682145805601770481850155216158966439415087541971706390030633064884729407638923224
    , prob =  2.95649080315475971549e-190



```python
# Hmm ok, so this module clearly handles the numbers nicely, 
# but there must be some flaw in my calculation..
```
